~~~c
//线程有自己独立的栈区，共享数据区和堆区
每个进程有自己独立的内存空间，创建进程的时候需要cpu，进行上下文切换的时候，需要把一个线程移出内存，另一个线程进入内存，开销很大，进程间数据交换也需要特殊的IPC技术。
1.线程销毁
int pthread_join(pthread_t thread, void **status);
等待线程终止，还可以引导线程销毁，但是线程终止前，调用该函数的线程将处于阻塞状态，
int pthread_detach(pthread_t thread)；
不会进入阻塞状态，把线程的控制权交还给系统。
    
2.工作线程
比如计算1~10的和，不是在main中进行累加运算，而是一个线程计算1~5，另一个线程计算6~10,main()只负责输出结果。
数组中含有两个元素，一个开始，一个结束，，循环累加sum变量，但会有脏写，要互斥的访问才行。
    
3.条件触发和边沿触发
区别在于发生事件的时间点，条件触发中，只要输入缓冲有数据就会一直通知该事件；边沿触发中，输入缓冲区收到数据时仅注册一次该事件，即使输入缓冲区还有数据，也不会再进行注册。
比如服务端每次收到客户端数据的时候，都会注册事件，多次调用epoll_wait函数，
验证输入缓冲区为空，read返回值为-1，同时error中保存的变量为EAGAIN。
边沿方式下，以阻塞方式工作的read/write可能会引起服务器长时间停顿，
边沿触发可以分离接收数据和处理数据的时间点，条件触发在输入缓冲区收到数据时，如果延迟处理，则每次调用epoll_wait()函数的时候都会产生相应事件。
~~~


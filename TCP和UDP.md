### TCP特点

~~~c
特点：面向连接，全双工，速度慢，可靠数据传输
    如何保证可靠？
    	1.采样随机序列号 --- 防止黑客获取，保证系统稳定性
    	2.确认重传机制
    	3.滑动窗口协议
~~~

### 三次握手

~~~c
标志位：ACK -- 协议规定，数据传输都要加ACK
        SYN -- =1,表示发起一个连接请求
    	FIN -- =1，表示报文发完
//三次握手 A <--->B   发送的有连接请求和数据包
    1.SYN=1,seq=x   A-->B
    2.SYN=1,ACK=1,seq=y,ack=x+1 
    3.ACK=1,seq=x+1,ack=y+1
    ACK--不占用序列号，表明确认号是合法的
    ack=x+1,ack是确认号，
    	1.希望下次发送包的序列号
    	2.SYN占用了一个序列号
三次握手为应用程序提供可靠的通信连接，适用于一次传输大批数据。
 //三次握手中丢失的探讨：
A先向B发送连接请求：
第一次握手丢失，会触发A的超时重传机制；
第二次握手丢失，A和B都以为对方没有收到自己的连接请求，会触发A和B的超时重传机制；
第三次握手丢失，1.如果双方都没有发送数据，B没收到A的确认信息，会重发一下；
    		  2.A要发送数据，而数据包的序列号就是x+1，B收到以后，会认为连接建立完成；
    		  3.B要发送给A数据，由于B没收到第二次握手确认，会一直重传第二次握手消息。
    
 //为什么要三次，两次行不行？
TCP是面向连接的，双方在发生数据之前要建立连接，建立连接包括参数的设置、内存空间的分配，收发双方参数的协商等，前两次握手建立连接，第三次握手确认连接可靠；
如果只有两次握手的话，客户端发送一个连接请求SYN报文段，而这个报文段由于网络原因，服务端暂时没有收到，而客户端认为丢包，又重发一个SYN，而此时建立了连接，等连接释放以后，客户端之前发的SYN有被服务器收到了，服务器就会认为客户端有连接请求，会继续向客户端发送数据，而此刻客户端已经关闭了，这样就会造成资源的浪费。
    
//三次握手过程，内核干了啥？
B收到A的连接请求，放入半连接队列(最大128，取系统配置和listen()中最小的，listen()是指定的)
B发出连接请求，当收到第三次连接的时候，内核会将其从半连接队列加入全连接队列，内核空闲的时候，accept()从连接队列中取出第一个。
~~~

### 四次挥手

~~~c
产生原因：通信双方结束通信，为了关闭各自的收发缓冲区，引入了四次挥手。
A <--->B,A先向B发送断开连接的请求
四次挥手：
    1.FIN=1,seq=u     --- FIN也占用一个序列号
    2.ACK=1,seq=v,ack=u+1；
    
    3.FIN=1,ACK=1,seq=w,ack=u+1
    4.ACK=1,seq=u+1,ack=w+1     --- B立即关闭数据通道
 A经过一定时间2MSL(Linux中60s)等待，A的连接才关闭
    因为60s的时间，能够让网络中延迟的数据包到达跳数并消失
    1.对第四次挥手的确认，保证通信双方的四次挥手能够顺利完成，正常关闭TCP连接，(如果客户端发送完第四次挥手后直接关闭连接，此时第四次挥手丢失，服务端由于没收到确认信息，会重传第三次挥手；那么服务器就不能按正常步骤进入close状态。这样就会耗费服务器的资源）
    2.保证B在2,3两次挥手的时候发送的旧的报文在网络中消失，这样在下一次连接的时候就不会出现旧连接的报文段啦。
 若改为3次，将第2,3两次合并，B在第3次没有数据传输的情况下。
~~~

### UDP特点

~~~c
1.没有各种连接：在传输数据前不需要建立连接；
2.不重新排序：对到达顺序混乱的数据包不进行重新排序；
3.没有确认：发送的数据包无需等待对方确认，可以用udp协议随时发送数据，但无法保证数据成功被对方接收；
 丢包问题：
  	操作系统的UDP 接收流程如下：收到一个UDP 包后，验证没有错误后，放入一个包队列中，队列中的每一个元素就是一个完整的UDP 包。当应用程序通过recvfrom()读取时，OS 把相应的一个完整UDP 包取出，然后拷贝到用户提供的内存中，物理用户提供的内存大小是多少，OS 都会完整取出一个UDP 包。如果用户提供的内存小于这个UDP 包的大小，那么在填充满内存后，UDP 包剩余的部分就会被丢弃，以后再也无法取回。  
UDP协议包括：TFTP,SNMP,NFS,DNS,BOOTP
~~~

### 协议选择

~~~c
1.对数据可靠性要求高的应用，比如验证码，密码的传送需要选择TCP协议；而对数据可靠性要求不那么高的应用，可以选择UDP协议；
2.对实时性要求比较高的应用，比如语音通话，视频监控等，选择UDP协议，而对实时性要求不那么高的应用可以选择TCP协议；
3.在网络状况比较差的情况下，比如广域网中，选择TCP协议，而在网络状况良好的情况下，可以选择UDP协议来减少网络负荷。
~~~


~~~c
1.每个线程都拥有一个独立的程序计数器，进程栈和一组进程寄存器。
  内核调度的对象时线程，而不是进程。
  进程是处于执行期间的程序以及相关资源的总称。
2.进程的创建，fork()系统调用(最终调用了clone())，该系统调用通过复制一个现有进程来创建一个全新的进程；子进程在返回点上开始执行。
  fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。
   fork()是创建一个新进程，然后使用exec()载入二进制映像，替换当前进程的映像。
  通常创建新的进程是为了执行新的，不同的程序，接着调用exec()这组函数可以创建新的地址空间，把新的程序载入其中。
3.程序通过exit()系统调用退出执行，进程退出执行以后被设置成僵死状态，直到它的父进程调用wait()或waitpid()为止。
4.linux中，进程的另一个名字叫task；
  内核把进程的列表存放在叫任务队列(task list)的双向循环链表中，链表中的每一项都是类型为task_struct，叫进程描述符(包含一个进程的所有信息)的结构。
  进程描述符中包含的数据能完整的描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多信息。
   访问任务通常需要指向其task_struct的指针，内核中大部分处理进程的代码都是直接通过task_student进行的。
5.写时拷贝
  内核并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝，只有在需要写入的时候，数据才会被复制。
6.线程在linux中的实现
  从内核的角度看，它并没有线程这个概念，linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或定义特别的数据结构来表示线程。线程仅仅被视为一个与其他进程共享某些资源的进程，每个线程都拥有唯一属于自己的task_struct。
    
~~~

